var bundle = (function () {
    'use strict';

    class InfinityArcadeAPI {
      constructor() {
        // TODO: detect
        this.base_url = "http://localhost:3000/api";
      }
      async fetch(url, data = null) {
        console.log(`fetching ${url}...`);
        try {
          let response;
          if (data) {
            response = await fetch(url, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(data)
            });
          } else {
            response = await fetch(url);
          }
          const envelope = await response.json();
          if (envelope.status !== "success") {
            throw envelope.message;
          }
          return envelope.data;
        } catch (error) {
          console.error(error);
          throw error;
        }
      }
      async stream(url, data = null) {
        console.log(`streaming ${url}...`);
        try {
          if (!data) {
            return this.fetch(url);
          }
          return fetch(url, {
            method: "POST",
            headers: {
              accept: 'application/x-ndjson'
            },
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
            body: new URLSearchParams(data)
          });
        } catch (error) {
          console.error(error);
          throw error;
        }
      }
      async createSession() {
        return await this.fetch(`${this.base_url}/session/new`);
      }
      async saveGame(game) {
        return await this.fetch(`${this.base_url}/game/new`, game);
      }
      async generateGame(prompt_text = null) {
        return await this.fetch(`${this.base_url}/game/generate`, {
          prompt_text
        });
      }
      async getArt(slug) {
        return await this.fetch(`${this.base_url}/game/${slug}/art`);
      }
      async *startGame(game, session_id) {
        const response = await this.stream(`${this.base_url}/chat/${game.slug}/start`, {
          session_id
        });
        for await (const token of yieldStreamResponse(response)) {
          yield token;
        }
      }
      async *chat(chat_id, content) {
        const response = await this.stream(`${this.base_url}/chat/`, {
          chat_id,
          content
        });
        for await (const token of yieldStreamResponse(response)) {
          yield token;
        }
      }
    }
    async function* yieldStreamResponse(response) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        try {
          const read = await reader.read();
          if (read && !read.done) {
            const raw = decoder.decode(read.value);
            buffer += raw;
            let leftover = "";
            const chunks = buffer.split("\n");
            for (const chunk of chunks) {
              if (chunk) {
                // console.log(`'${chunk}'`);
                try {
                  yield JSON.parse(chunk);
                } catch (e) {
                  leftover += chunk;
                }
              }
            }
            buffer = leftover;
          } else {
            if (buffer) {
              try {
                yield JSON.parse(buffer);
              } catch (e) {
                console.log("ERROR PARSING LEFTOVER", buffer);
              }
            }
            break;
          }
        } catch (e) {
          console.log(e);
          console.error(`error while reading stream for ${chat_id}`);
          break;
        }
      }
    }
    var api = InfinityArcadeAPI;

    class InfinityArcadeGame {
      constructor(ia, game) {
        this.ia = ia;
        this.ui = ia.ui;
        this.game = game;
        this.chat_id = null;
        this.parent_id = null;
        this.streaming = false;
      }
      async loop() {
        this.render();
      }
      async streamFinished() {
        this.streaming = false;
        this.ui.showChatInput();

        // TODO: can optionally add in scene images...it's kinda fun but pretty slow/expensive and might be more useful when a better image API is available
        // this.ui.addSceneImage(this.chat_id);
      }

      async handleStream(stream) {
        this.streaming = true;
        for await (const response of stream) {
          await this.handleStreamObject(response);
        }
      }
      async handleStreamObject(obj) {
        if (this.ui.loading) {
          this.ui.stopLoading();
        }
        if (!obj) return;
        if (obj.type == "content") {
          this.ui.addText(obj.content);
        } else if (obj.type.indexOf("option") == 0) {
          this.ui.addOptionText(obj.type, obj.content);
        } else if (obj.type == "end") {
          this.chat_id = obj.chat_id;
          this.parent_id = obj.parent_id;
          await this.streamFinished();
        } else {
          console.log("UNKNOWN STREAM OBJ", JSON.stringify(obj));
        }
      }
      async start() {
        console.log(`Starting game: ${this.game.title}`);
        this.ui.enableGameUI();
        await this.handleStream(this.ia.api.startGame(this.game, this.ia.session_id));
      }
      async handleOptionClick(event) {
        event.preventDefault();
        const el = event.target;
        if (!el) return;
        if (this.ui.loading || this.streaming) {
          console.log("Already loading");
          return;
        }
        if (!this.chat_id) {
          this.start();
          return;
        }
        await this.chat(el.innerText);
      }
      async handleChatSubmit(event) {
        event.preventDefault();
        await this.chat(this.ui.chat_input.value);
      }
      async chat(input) {
        this.ui.startLoading();
        await this.handleStream(this.ia.api.chat(this.chat_id, input));
      }
      async setup() {
        this.ui.button1.onclick = this.handleOptionClick.bind(this);
        this.ui.button2.onclick = this.handleOptionClick.bind(this);
        this.ui.button3.onclick = this.handleOptionClick.bind(this);
        this.ui.button4.onclick = this.handleOptionClick.bind(this);
        this.ui.chat_form.onsubmit = this.handleChatSubmit.bind(this);
        this.ui.image.onload = e => {
          this.ui.hideImageLoader();
        };
        window.onkeydown = e => {
          switch (e.key) {
            case "1":
              e.preventDefault();
              this.ui.button1.click();
              break;
            case "2":
              e.preventDefault();
              this.ui.button2.click();
              break;
            case "3":
              e.preventDefault();
              this.ui.button3.click();
              break;
            case "4":
              e.preventDefault();
              this.ui.button4.click();
              break;
          }
        };
      }
    }
    var game = InfinityArcadeGame;

    class UserInterface {
      constructor() {
        this.image = document.getElementById("image");
        this.tagline = document.getElementById("tagline");
        this.genre_wrapper = document.getElementById("genre-wrapper");
        this.image_loader = document.getElementById("image-loader");
        this.image_wrapper = document.getElementById("image-wrapper");
        this.dot_loader = document.getElementById("dot-loader");
        this.text = document.getElementById("text");
        this.chat = document.getElementById("chat");
        this.chat_form = document.getElementById("chat-form");
        this.chat_input = document.getElementById("chat-input");
        this.option1 = document.getElementById("option1");
        this.button1 = document.getElementById("button1");
        this.option2 = document.getElementById("option2");
        this.button2 = document.getElementById("button2");
        this.option3 = document.getElementById("option3");
        this.button3 = document.getElementById("button3");
        this.option4 = document.getElementById("option4");
        this.button4 = document.getElementById("button4");
        this.loading = false;
      }
      setText(content) {
        this.text.innerHTML = content;
        this.text.style.display = "flex";
      }
      addText(content) {
        this.text.innerHTML += content;
        this.text.style.display = "flex";
      }
      addOptionText(option, content) {
        if (option == "option1") {
          this.option1.style.display = "block";
          this.button1.innerHTML += content;
        } else if (option == "option2") {
          this.option2.style.display = "block";
          this.button2.innerHTML += content;
        } else if (option == "option3") {
          this.option3.style.display = "block";
          this.button3.innerHTML += content;
        } else if (option == "option4") {
          this.option4.style.display = "block";
          this.button4.innerHTML += content;
        }
      }
      addSceneImage(chat_id) {
        const sceneImage = document.createElement('img');
        sceneImage.src = `/api/art/generate?chat_id=${chat_id}`;
        this.image_wrapper.insertBefore(sceneImage, this.image_wrapper.firstChild);
      }
      showChatInput() {
        this.chat.style.display = "flex";
        this.chat_input.focus();
      }
      imageLoaded() {
        return this.image && this.image.complete;
      }
      showDotLoader() {
        this.dot_loader.style.display = "block";
      }
      hideDotLoader() {
        this.dot_loader.style.display = "none";
      }
      hideImageLoader() {
        this.image_loader.style.display = "none";
      }
      showImageLoader() {
        this.image_loader.style.display = "block";
      }
      reset() {
        this.resetText();
        this.resetOptions();
        this.resetChat();
        this.showDotLoader();
      }
      resetText() {
        this.setText("");
        this.text.scrollTop = 0;
      }
      resetChat() {
        this.chat.style.display = "none";
        this.chat_input.value = "";
      }
      resetOptions() {
        this.button1.innerHTML = "";
        this.button2.innerHTML = "";
        this.button3.innerHTML = "";
        this.button4.innerHTML = "";
        this.option1.style.display = "none";
        this.option2.style.display = "none";
        this.option3.style.display = "none";
        this.option4.style.display = "none";
      }
      enableGameUI() {
        this.tagline.style.display = "none";
        this.genre_wrapper.style.display = "none";
        this.text.classList.remove("h-full");
        this.text.classList.remove("grow");
        this.text.style.removeProperty("max-height");
        this.text.style.height = "400px";
        this.startLoading();
      }
      startLoading() {
        this.loading = true;
        this.reset();
      }
      stopLoading() {
        this.loading = false;
        this.hideDotLoader();
      }
    }
    var ui = UserInterface;

    function setCookie$1(name, value, days) {
      var expires = "";
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }
    function getCookie$1(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }
    function eraseCookie(name) {
      document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    }
    var utils = {
      setCookie: setCookie$1,
      getCookie: getCookie$1,
      eraseCookie
    };

    const {
      getCookie,
      setCookie
    } = utils;
    class InfinityArcade {
      constructor() {
        this.api = new api();
        this.ui = new ui();
        this.game = null;
        this.session_id = null;
      }
      get params() {
        return new Proxy(new URLSearchParams(window.location.search), {
          get: (searchParams, prop) => searchParams.get(prop)
        });
      }
      async handleGame(game$1) {
        this.game = new game(this, game$1);
        await this.game.setup();
      }
      async handleGenerate() {
        const prompt_text = this.params.prompt_text;
        const game = await this.api.generateGame(prompt_text);
        document.location = `/${game.slug}`;
      }
      static async initialize(api) {
        const ia = new InfinityArcade();
        ia.session_id = await ia.getOrCreateSession();
        console.log(`initialized InfinityArcade with session_id ${ia.session_id}`);
        return ia;
      }
      async getOrCreateSession() {
        let session_id = getCookie("ia_session_id");
        if (!session_id) {
          session_id = await this.api.createSession();
          setCookie("ia_session_id", session_id);
        }
        if (!session_id) {
          throw "Error: Could not create session";
        }
        return session_id;
      }
    }
    var app = InfinityArcade;

    app.initialize().then(ia => {
      window.ia = ia;
    });

    var client = {

    };

    return client;

})();
