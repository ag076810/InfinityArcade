var bundle = (function () {
    'use strict';

    class InfinityArcadeAPI {
      constructor() {
        if (document.location.href.indexOf("http://localhost:3000") == 0) {
          this.base_url = "http://localhost:3000/api";
        } else if (document.location.href.indexOf("http://192.168.4.103:3000") == 0) {
          this.base_url = "http://192.168.4.103:3000/api";
        } else {
          this.base_url = "https://infinityarcade.com/api";
        }
      }
      async fetch(url, data = null) {
        console.log(`fetching ${url}...`);
        try {
          let response;
          if (data) {
            response = await fetch(url, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(data)
            });
          } else {
            response = await fetch(url);
          }
          const envelope = await response.json();
          if (envelope.status !== "success") {
            throw envelope.message;
          }
          return envelope.data;
        } catch (error) {
          console.error(error);
          throw error;
        }
      }
      async stream(url, data = null) {
        console.log(`streaming ${url}...`);
        try {
          if (!data) {
            return this.fetch(url);
          }
          return fetch(url, {
            method: "POST",
            headers: {
              accept: 'application/x-ndjson'
            },
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
            body: new URLSearchParams(data)
          });
        } catch (error) {
          console.error(error);
          throw error;
        }
      }
      async createSession() {
        return await this.fetch(`${this.base_url}/session/new`);
      }
      async saveGame(game) {
        return await this.fetch(`${this.base_url}/game/new`, game);
      }
      async generateGame(prompt_text = null) {
        return await this.fetch(`${this.base_url}/game/generate`, {
          prompt_text
        });
      }
      async getArt(slug) {
        return await this.fetch(`${this.base_url}/game/${slug}/art`);
      }
      async *startGame(game, session_id) {
        const response = await this.stream(`${this.base_url}/chat/${game.slug}/start`, {
          session_id
        });
        for await (const token of yieldStreamResponse(response)) {
          yield token;
        }
      }
      async *chat(chat_id, content) {
        const response = await this.stream(`${this.base_url}/chat/`, {
          chat_id,
          content
        });
        for await (const token of yieldStreamResponse(response)) {
          yield token;
        }
      }
      async updateAccount(options) {
        return await this.fetch(`${this.base_url}/account`, options);
      }
      async fetchGames(page = 1, limit = 10, params = null) {
        if (!params) params = {};
        const query = Object.assign({}, {
          page,
          limit
        }, params);
        const queryString = Object.keys(query).map(key => key + '=' + query[key]).join('&');
        const url = `${this.base_url}/games?${queryString}`;
        console.log(url);
        return await this.fetch(url);
      }
    }
    async function* yieldStreamResponse(response) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        try {
          const read = await reader.read();
          if (read && !read.done) {
            const raw = decoder.decode(read.value);
            buffer += raw;
            let leftover = "";
            const chunks = buffer.split("\n");
            for (const chunk of chunks) {
              if (chunk) {
                // console.log(`'${chunk}'`);
                try {
                  yield JSON.parse(chunk);
                } catch (e) {
                  leftover += chunk;
                }
              }
            }
            buffer = leftover;
          } else {
            if (buffer) {
              try {
                yield JSON.parse(buffer);
              } catch (e) {
                console.log("ERROR PARSING LEFTOVER", buffer);
              }
            }
            break;
          }
        } catch (e) {
          console.log(e);
          console.error(`error while reading stream for ${chat_id}`);
          break;
        }
      }
    }
    var api = InfinityArcadeAPI;

    class InfinityArcadeGame {
      constructor(ia, game) {
        this.ia = ia;
        this.ui = ia.ui;
        this.game = game;
        this.chat_id = null;
        this.parent_id = null;
        this.streaming = false;
        this.game_ui_loaded = false;
      }
      async streamFinished() {
        this.streaming = false;
        this.ui.showChatInput();

        // TODO: can optionally add in scene images...it's kinda fun but pretty slow/expensive and might be more useful when a better image API is available
        // this.ui.addSceneImage(this.chat_id);
      }

      async handleStream(stream) {
        this.streaming = true;
        for await (const response of stream) {
          await this.handleStreamObject(response);
        }
      }
      async handleStreamObject(obj) {
        if (!this.game_ui_loaded) {
          this.ui.enableGameUI();
          this.game_ui_loaded = true;
        }
        if (this.ui.loading) {
          this.ui.stopLoading();
        }
        if (!obj) return;
        if (!obj.chat_id) return;
        if (!obj.parent_id) return;
        this.chat_id = obj.chat_id;
        this.parent_id = obj.parent_id;
        if (obj.type == "content") {
          const {
            created
          } = this.ui.addTextToChat(obj.content, obj.chat_id, "content");
          if (created) {
            this.scrollChatIntoView();
          }
        } else if (obj.type.indexOf("option") == 0) {
          this.ui.addOptionText(obj.type, obj.content);
        } else if (obj.type == "end") {
          await this.streamFinished();
        } else {
          console.log("UNKNOWN STREAM OBJ", JSON.stringify(obj));
        }
      }
      scrollChatIntoView() {
        this.ui.scrollend.scrollIntoView({
          behavior: 'smooth',
          block: 'end'
        });
      }
      async start() {
        console.log(`Starting game: ${this.game.title}`);
        this.ui.enableGameUI();
        this.game_ui_loaded = true;
        const link = `<a href="/${this.game.slug}">${this.game.title}</a>`;
        const {
          container
        } = this.ui.addTextToChat(link, `game-start`, null, true);
        container.style.color = this.game.primary_color;
        // this.scrollChatIntoView();

        await this.handleStream(this.ia.api.startGame(this.game, this.ia.session_id));
      }
      async handleOptionClick(event) {
        event.preventDefault();
        const el = event.target;
        if (!el) return;
        if (this.ui.loading || this.streaming) {
          console.log("Already loading");
          return;
        }
        if (!this.chat_id) {
          this.start();
          return;
        }
        const {
          container
        } = this.ui.addTextToChat(el.innerText.trim(), `${this.chat_id}-option`);
        container.style.color = this.game.primary_color;
        this.scrollChatIntoView();
        await this.chat(el.innerText);
      }
      async handleChatSubmit(event) {
        event.preventDefault();
        await this.chat(this.ui.chat_input.value);
      }
      async chat(input) {
        this.ui.startLoading();
        await this.handleStream(this.ia.api.chat(this.chat_id, input));
      }
      async setup() {
        this.ui.button1.onclick = this.handleOptionClick.bind(this);
        this.ui.button2.onclick = this.handleOptionClick.bind(this);
        this.ui.button3.onclick = this.handleOptionClick.bind(this);
        this.ui.button4.onclick = this.handleOptionClick.bind(this);
        this.ui.chat_form.onsubmit = this.handleChatSubmit.bind(this);
        this.ui.image.onload = e => {
          this.ui.hideImageLoader();
        };
        window.onkeydown = e => {
          switch (e.key) {
            case "1":
              e.preventDefault();
              this.ui.button1.click();
              break;
            case "2":
              e.preventDefault();
              this.ui.button2.click();
              break;
            case "3":
              e.preventDefault();
              this.ui.button3.click();
              break;
            case "4":
              e.preventDefault();
              this.ui.button4.click();
              break;
          }
        };
      }
    }
    var game = InfinityArcadeGame;

    class UserInterface {
      constructor() {
        this.videogame = document.getElementById("videogame");
        this.image = document.getElementById("image");
        this.tagline = document.getElementById("tagline");
        this.genre_wrapper = document.getElementById("genre-wrapper");
        this.image_loader = document.getElementById("image-loader");
        this.image_wrapper = document.getElementById("image-wrapper");
        this.dot_loader = document.getElementById("dot-loader");
        this.text = document.getElementById("text");
        this.chat = document.getElementById("chat");
        this.chat_form = document.getElementById("chat-form");
        this.chat_input = document.getElementById("chat-input");
        this.scrollend = document.getElementById("scrollend");
        this.option1 = document.getElementById("option1");
        this.button1 = document.getElementById("button1");
        this.option2 = document.getElementById("option2");
        this.button2 = document.getElementById("button2");
        this.option3 = document.getElementById("option3");
        this.button3 = document.getElementById("button3");
        this.option4 = document.getElementById("option4");
        this.button4 = document.getElementById("button4");
        this.chat_containers = {};
        this.loading = false;
      }
      setText(content) {
        this.text.innerHTML = content;
        this.text.style.display = "flex";
      }
      getChatContainer(chat_id, klass = null, addToStart = false) {
        if (this.chat_containers[chat_id]) {
          return {
            created: false,
            container: this.chat_containers[chat_id]
          };
        }
        console.log("Creating chat container");
        const container = document.createElement("div");
        container.id = `chat-${chat_id}`;
        if (klass) {
          container.classList.add(klass);
        }
        if (addToStart) {
          this.text.insertBefore(container, this.text.firstChild);
        } else {
          this.text.appendChild(container);
        }
        this.chat_containers[chat_id] = container;
        return {
          created: true,
          container
        };
      }
      addTextToChat(content, chat_id, klass = null, addToStart = false) {
        const {
          created,
          container
        } = this.getChatContainer(chat_id, klass, addToStart);
        container.innerHTML += content;
        return {
          created,
          container
        };
      }
      addOptionText(option, content) {
        if (option == "option1") {
          this.option1.style.display = "block";
          this.button1.innerHTML += content;
        } else if (option == "option2") {
          this.option2.style.display = "block";
          this.button2.innerHTML += content;
        } else if (option == "option3") {
          this.option3.style.display = "block";
          this.button3.innerHTML += content;
        } else if (option == "option4") {
          this.option4.style.display = "block";
          this.button4.innerHTML += content;
        }
      }
      addSceneImage(chat_id) {
        const sceneImage = document.createElement('img');
        sceneImage.src = `/api/art/generate?chat_id=${chat_id}`;
        this.image_wrapper.insertBefore(sceneImage, this.image_wrapper.firstChild);
      }
      showChatInput() {
        this.chat.style.display = "flex";
      }
      imageLoaded() {
        return this.image && this.image.complete;
      }
      showDotLoader() {
        this.dot_loader.style.display = "block";
      }
      hideDotLoader() {
        this.dot_loader.style.display = "none";
      }
      hideImageLoader() {
        this.image_loader.style.display = "none";
      }
      showImageLoader() {
        this.image_loader.style.display = "block";
      }
      reset() {
        // this.text.innerHTML += "<br /><br />"
        this.resetOptions();
        this.resetChat();
        this.showDotLoader();
      }
      resetText() {
        this.setText("");
        this.text.scrollTop = 0;
      }
      resetChat() {
        this.chat.style.display = "none";
        this.chat_input.value = "";
      }
      resetOptions() {
        this.button1.innerHTML = "";
        this.button2.innerHTML = "";
        this.button3.innerHTML = "";
        this.button4.innerHTML = "";
        this.option1.style.opacity = 1; // mobile hover bug
        this.option2.style.opacity = 1;
        this.option3.style.opacity = 1;
        this.option4.style.opacity = 1;
        this.option1.style.display = "none";
        this.option2.style.display = "none";
        this.option3.style.display = "none";
        this.option4.style.display = "none";
      }
      enableGameUI() {
        document.body.classList.add("ia-game-started");
        this.startLoading();
      }
      startLoading() {
        this.loading = true;
        this.reset();
      }
      stopLoading() {
        this.loading = false;
        this.hideDotLoader();
      }
    }
    var ui = UserInterface;

    class Radio {
      constructor() {
        this.audio = null;
        this.autoplay = true;
        this.index = 0;
        this.catalog = ["CHIPTUNE_Minstrel_Dance.mp3", "CHIPTUNE_The_Bards_Tale.mp3", "CHIPTUNE_The_Old_Tower_Inn.mp3", "HinaCC0_011_Fallen_leaves.mp3", "Komiku_-_02_-_Boss_4__Cobblestone_in_their_face.mp3", "Komiku_-_02_-_Poupis_Theme.mp3", "Komiku_-_04_-_Shopping_List.mp3", "Komiku_-_07_-_Last_Boss__Lets_see_what_we_got.mp3", "Loyalty_Freak_Music_-_02_-_High_Technologic_Beat_Explosion.mp3", "Loyalty_Freak_Music_-_04_-_Cant_Stop_My_Feet_.mp3", "Loyalty_Freak_Music_-_04_-_It_feels_good_to_be_alive_too.mp3", "draft-monk-ambience.mp3", "ocean-of-ice.mp3", "雪のテーマ-Snow-field-.mp3"];
      }
      initialize() {
        console.log("INITIALIZE RADIO");
        this.toggleRadio = document.getElementById("radio-toggle");
        this.nextRadio = document.getElementById("radio-next");
        this.prevRadio = document.getElementById("radio-prev");
        this.iconPlay = document.getElementById("icon-play");
        this.iconStop = document.getElementById("icon-stop");
        this.toggleRadio.onclick = this.handleToggleRadioClick.bind(this);
        this.nextRadio.onclick = this.handleClickNext.bind(this);
        this.prevRadio.onclick = this.handleClickPrev.bind(this);
      }
      handleToggleRadioClick(e) {
        e.preventDefault();
        if (this.audio) {
          this.stop();
        } else {
          this.play();
        }
      }
      handleClickNext(e) {
        e.preventDefault();
        this.next();
      }
      handleClickPrev(e) {
        e.preventDefault();
        this.prev();
      }
      songEnded() {
        console.log("SONG ENDED");
        this.audio = null;
        if (this.autoplay) {
          this.next();
        }
      }
      get song() {
        if (this.index >= this.catalog.length) {
          this.index = 0;
        }
        if (this.index < 0) {
          this.index = this.catalog.length - 1;
        }
        return this.catalog[this.index];
      }
      play() {
        if (this.audio) {
          this.audio.pause();
          this.audio = null;
        }
        console.log(`PLAYING ${this.song}`);
        this.audio = new Audio(`/mp3/${this.song}`);
        this.audio.volume = 0.2;
        this.audio.addEventListener('ended', this.songEnded.bind(this));
        this.audio.play();
        this.render();
      }
      stop() {
        if (this.audio) {
          console.log("STOPPING");
          this.audio.pause();
          this.audio = null;
          this.render();
        }
      }
      next() {
        this.index++;
        this.play();
      }
      prev() {
        this.index--;
        this.play();
      }
      render() {
        if (this.audio) {
          this.iconPlay.style.display = "block";
          this.iconStop.style.display = "none";
        } else {
          this.iconPlay.style.display = "none";
          this.iconStop.style.display = "block";
        }
      }
    }
    var radio = Radio;

    function setCookie$1(name, value, days) {
      var expires = "";
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }
    function getCookie$1(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
      }
      return null;
    }
    function eraseCookie(name) {
      document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    }
    var utils = {
      setCookie: setCookie$1,
      getCookie: getCookie$1,
      eraseCookie
    };

    const {
      getCookie,
      setCookie
    } = utils;
    class InfinityArcade {
      constructor() {
        this.api = new api();
        this.ui = new ui();
        this.radio = new radio();
        this.game = null;
        this.session_id = null;
      }
      sendEvent(name) {
        const event = new CustomEvent(name);
        document.dispatchEvent(event);
      }
      get params() {
        return new Proxy(new URLSearchParams(window.location.search), {
          get: (searchParams, prop) => searchParams.get(prop)
        });
      }
      async handleGame(game$1, options = null) {
        this.game = new game(this, game$1);
        await this.game.setup();
        if (options.parent_id && options.chat_id && options.action == "resume") {
          this.game.parent_id = options.parent_id;
          this.game.chat_id = options.chat_id;
          this.ui.button1.innerHTML = `Resume ${this.game.game.title}!`;
        }
      }
      async handleGenerate() {
        const prompt_text = this.params.prompt_text;
        const game = await this.api.generateGame(prompt_text);
        document.location = `/${game.slug}`;
      }
      async handleRadio() {
        this.radio.initialize();
      }
      static async initialize(api) {
        const ia = new InfinityArcade();
        ia.session_id = await ia.getOrCreateSession();
        console.log(`initialized InfinityArcade with session_id ${ia.session_id}`);
        return ia;
      }
      async getOrCreateSession() {
        let session_id = getCookie("ia_session_id");
        if (!session_id) {
          session_id = await this.api.createSession();
          setCookie("ia_session_id", session_id);
        }
        if (!session_id) {
          throw "Error: Could not create session";
        }
        return session_id;
      }
    }
    var app = InfinityArcade;

    app.initialize().then(ia => {
      window.ia = ia;
      ia.sendEvent("ia-loaded");
    });

    var client = {

    };

    return client;

})();
